import { unref as ee, defineComponent as A, ref as p, computed as T, openBlock as M, createElementBlock as O, normalizeClass as R, createElementVNode as $, normalizeStyle as C, watch as te, reactive as ne, onMounted as re, nextTick as oe, onBeforeUnmount as ie, resolveComponent as le, createBlock as se, resolveDynamicComponent as ae, mergeProps as ce, withCtx as B, Fragment as ue, renderList as fe, renderSlot as de, createVNode as me } from "vue";
import { _ as q } from "./GSArrow-d3dc6242.mjs";
import { G as Xe } from "./GSLayoutDefault-6bcb48f1.mjs";
import { G as je } from "./GSLayoutNumeric-93bbaef6.mjs";
function D(e) {
  return typeof e == "function" ? e() : ee(e);
}
const z = () => {
};
function X(e, t) {
  function n(...s) {
    return new Promise((o, i) => {
      Promise.resolve(e(() => t.apply(this, s), { fn: t, thisArg: this, args: s })).then(o).catch(i);
    });
  }
  return n;
}
function ve(e, t = {}) {
  let n, s, o = z;
  const i = (r) => {
    clearTimeout(r), o(), o = z;
  };
  return (r) => {
    const c = D(e), d = D(t.maxWait);
    return n && i(n), c <= 0 || d !== void 0 && d <= 0 ? (s && (i(s), s = null), Promise.resolve(r())) : new Promise((b, h) => {
      o = t.rejectOnCancel ? h : b, d && !s && (s = setTimeout(() => {
        n && i(n), s = null, b(r());
      }, d)), n = setTimeout(() => {
        s && i(s), s = null, b(r());
      }, c);
    });
  };
}
function Se(e, t = !0, n = !0, s = !1) {
  let o = 0, i, a = !0, r = z, c;
  const d = () => {
    i && (clearTimeout(i), i = void 0, r(), r = z);
  };
  return (h) => {
    const m = D(e), u = Date.now() - o, v = () => c = h();
    return d(), m <= 0 ? (o = Date.now(), v()) : (u > m && (n || !a) ? (o = Date.now(), v()) : t && (c = new Promise((w, I) => {
      r = s ? I : w, i = setTimeout(() => {
        o = Date.now(), a = !0, w(v()), d();
      }, Math.max(0, m - u));
    })), !n && !i && (i = setTimeout(() => a = !0, m)), a = !1, c);
  };
}
function he(e, t = 200, n = {}) {
  return X(
    ve(t, n),
    e
  );
}
function ye(e, t = 200, n = !1, s = !0, o = !1) {
  return X(
    Se(t, n, s, o),
    e
  );
}
var be = 4, we = 1e-3, ge = 1e-7, pe = 10, W = 11, L = 1 / (W - 1), Ie = typeof Float32Array == "function";
function _(e, t) {
  return 1 - 3 * t + 3 * e;
}
function j(e, t) {
  return 3 * t - 6 * e;
}
function V(e) {
  return 3 * e;
}
function F(e, t, n) {
  return ((_(t, n) * e + j(t, n)) * e + V(t)) * e;
}
function U(e, t, n) {
  return 3 * _(t, n) * e * e + 2 * j(t, n) * e + V(t);
}
function Pe(e, t, n, s, o) {
  var i, a, r = 0;
  do
    a = t + (n - t) / 2, i = F(a, s, o) - e, i > 0 ? n = a : t = a;
  while (Math.abs(i) > ge && ++r < pe);
  return a;
}
function Te(e, t, n, s) {
  for (var o = 0; o < be; ++o) {
    var i = U(t, n, s);
    if (i === 0)
      return t;
    var a = F(t, n, s) - e;
    t -= a / i;
  }
  return t;
}
function ke(e) {
  return e;
}
var Me = function(e, t, n, s) {
  if (!(0 <= e && e <= 1 && 0 <= n && n <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (e === t && n === s)
    return ke;
  for (var o = Ie ? new Float32Array(W) : new Array(W), i = 0; i < W; ++i)
    o[i] = F(i * L, e, n);
  function a(r) {
    for (var c = 0, d = 1, b = W - 1; d !== b && o[d] <= r; ++d)
      c += L;
    --d;
    var h = (r - o[d]) / (o[d + 1] - o[d]), m = c + h * L, u = U(m, e, n);
    return u >= we ? Te(r, m, e, n) : u === 0 ? m : Pe(r, c, c + L, e, n);
  }
  return function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : F(a(r), t, s);
  };
};
const We = {
  ease: [0.25, 0.1, 0.25, 1],
  linear: [0, 0, 1, 1],
  easeIn: [0.42, 0, 1, 1],
  easeOut: [0, 0, 0.58, 1],
  easeInOut: [0.42, 0, 0.58, 1],
  default: [0.5, 0, 0.5, 1]
}, Le = {
  FPS: 60,
  BEZIER: We.default
}, Oe = ({
  from: e,
  to: t,
  duration: n,
  bezier: s = Le.BEZIER,
  on: o,
  completed: i,
  stopped: a,
  done: r
}) => {
  const c = Me(...s), d = t - e, b = Date.now();
  let h = 0, m = e;
  const u = () => {
    let v = (Date.now() - b) / n;
    if (v > 1 && (v = 1), m = e + d * c(v), o(m), v === 1) {
      i == null || i(m), r == null || r(m);
      return;
    }
    h = requestAnimationFrame(u);
  };
  return h = requestAnimationFrame(u), () => {
    cancelAnimationFrame(h), a == null || a(m), r == null || r(m);
  };
}, $e = (e) => {
  let t = 0, n = null;
  return {
    setSmoothly: (i, a) => {
      n == null || n(), a && (t = a), n = Oe({
        duration: 400,
        from: t,
        to: i,
        on: (r) => {
          t = r, e(r);
        }
      });
    },
    setImmediately: (i) => {
      t = i, e(i);
    }
  };
}, ze = A({
  name: "GSIndicator",
  props: {
    barWidthPercent: {
      type: Number,
      required: !0
    },
    barOffsetPercent: {
      type: Number,
      required: !0
    }
  },
  emits: {
    "smooth-scroll": (e) => !0,
    scroll: (e) => !0,
    "scroll:start": () => !0,
    "scroll:end": () => !0
  },
  setup(e, { emit: t }) {
    const n = p(), s = p(0), o = p(0), i = p(!1), a = (h) => {
      const u = h.clientX - s.value, v = n.value.offsetWidth, w = u / v * 100, I = 0, g = 100 - e.barWidthPercent;
      let P = o.value + w;
      P < I ? P = I : P > g && (P = g), t("scroll", {
        barOffsetPercent: P
      });
    }, r = () => {
      document.removeEventListener("mouseup", r), document.removeEventListener("mousemove", a), i.value = !1, t("scroll:end");
    }, c = (h) => {
      i.value = !0, t("scroll:start"), document.addEventListener("mouseup", r), document.addEventListener("mousemove", a), s.value = h.clientX, o.value = e.barOffsetPercent;
    }, d = (h) => {
      const m = h.clientX, u = n.value, v = u.getBoundingClientRect().left, g = ((m - v) / u.offsetWidth - e.barWidthPercent / 100 / 2) * 100;
      t("smooth-scroll", {
        barOffsetPercent: g
      });
    }, b = T(() => ({
      width: `${e.barWidthPercent}%`,
      left: `${e.barOffsetPercent}%`
    }));
    return {
      indicatorRef: n,
      barStyle: b,
      startBarX: s,
      startBarOffsetPercent: o,
      moving: i,
      onTrackClick: d,
      onMouseDown: c
    };
  }
});
function Fe(e, t, n, s, o, i) {
  return M(), O("div", {
    ref: "indicatorRef",
    class: R(["gsc-indicator", {
      "gsc-indicator--scrolling": e.moving
    }])
  }, [
    $("div", {
      class: "gsc-indicator__track",
      onClick: t[0] || (t[0] = (...a) => e.onTrackClick && e.onTrackClick(...a))
    }),
    $("div", {
      class: "gsc-indicator__bar",
      style: C(e.barStyle),
      onMousedown: t[1] || (t[1] = (...a) => e.onMouseDown && e.onMouseDown(...a))
    }, null, 36)
  ], 2);
}
const Ce = /* @__PURE__ */ q(ze, [["render", Fe], ["__scopeId", "data-v-43b724a6"]]), De = A({
  name: "GSCarousel",
  components: {
    GSIndicator: Ce
  },
  props: {
    currentItem: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      required: !0
    },
    // How much items in the view
    itemsToShow: {
      type: Number,
      required: !0
    },
    // Key field name for :key in v-for
    // (using index by default)
    keyField: {
      type: String,
      default: null
    },
    // Gap around each item.
    // Value '12' means 'padding: 6px;' for each item.
    // Value '12 20' means 'padding: 6px 10px;' for each item.
    itemGap: {
      type: [String, Number],
      default: "0",
      validator: (e) => {
        const t = e.toString().split(" ");
        return t.length <= 2 && t.every((n) => !isNaN(parseInt(n)));
      }
    },
    // The visible part of the next element in the carousel
    previewSize: {
      type: Number,
      default: 120
    },
    // Enables sticking to the sides of the carousel
    sticky: {
      type: Boolean,
      default: !1
    },
    // layout component
    layout: {
      type: Object,
      required: !0
    },
    // layout specific props
    layoutProps: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * Item min-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMinWidth: {
      type: [Number, String],
      default: null
    },
    /**
     * Item max-width on app startup when html is displayed,
     * but js is not loaded yet.
     * It correct's the item width in SSR mode.
     */
    ssrItemMaxWidth: {
      type: [Number, String],
      default: null
    }
  },
  emits: {
    "update:current-item": (e) => !0
  },
  setup(e, { emit: t, expose: n }) {
    const s = p(!1), o = p(), i = p("left"), a = p(0), r = p(e.currentItem || 0);
    te(() => e.currentItem, (l) => {
      r.value = l;
    });
    const c = ne({
      isScrolling: !1,
      barOffsetPercent: 0,
      barWidthPercent: 0
    }), d = T(() => {
      const l = c.barOffsetPercent / (100 - c.barWidthPercent);
      return Math.floor(l * (e.items.length - 1));
    }), {
      setImmediately: b,
      setSmoothly: h
    } = $e(
      (l) => {
        var f;
        return (f = o.value) == null ? void 0 : f.scrollTo({
          left: l
        });
      }
    ), m = T(() => {
      const l = e.itemGap.toString().split(" ").map((S) => parseInt(S)), f = l[0], y = l.length === 1 ? f : l[1];
      return { y: f, x: y };
    }), u = T(() => a.value ? (a.value - e.previewSize) / e.itemsToShow : 0), v = (l, f = !0) => {
      if (f) {
        const y = o.value.scrollLeft;
        h(l, y);
      } else
        b(l);
    }, w = () => {
      const l = o.value.scrollLeft, f = l / u.value, y = 1 - (f - Math.floor(f));
      let S;
      return y < 0.09 ? S = Math.floor(f) + 1 : S = Math.floor(f), S * u.value < l && (S += 1), S > e.items.length - 1 && (S = e.items.length - 1), S;
    }, I = (l) => {
      const f = o.value.scrollLeft, y = w();
      if (l === 1) {
        let S = y + e.itemsToShow;
        y * u.value - e.previewSize - 2 > f && (S -= 1);
        const E = e.items.length - e.itemsToShow;
        S > E && (S = E);
        const x = u.value * S;
        v(x);
      } else if (l === -1) {
        if (y === 0)
          return;
        let S = y - e.itemsToShow;
        S < 0 && (S = 0);
        const N = u.value * S - e.previewSize;
        v(N);
      }
    }, g = (l) => {
      if (!u.value) {
        setTimeout(() => {
          g(l);
        }, 50);
        return;
      }
      if (l > w()) {
        const y = u.value * l;
        v(y);
        return;
      }
      const f = u.value * l - e.previewSize;
      v(f);
    }, P = ye(() => {
      const l = w();
      l !== r.value && (r.value = l, t("update:current-item", r.value));
    }, 200);
    let G = 0;
    const H = he((l) => {
      if (b(l), !(!e.sticky || c.isScrolling)) {
        if (G < l) {
          const f = u.value * r.value;
          v(f);
        } else if (Math.abs(u.value * r.value - l) > e.previewSize + 2) {
          const f = u.value * (r.value - 1) - e.previewSize;
          v(f);
        }
        G = l;
      }
    }, 300), Z = () => {
      const l = o.value.scrollLeft;
      l < 2 ? i.value = "left" : o.value.scrollWidth <= l + o.value.offsetWidth + 2 ? i.value = "right" : i.value = "none", c.barOffsetPercent = l / o.value.scrollWidth * 100, P(), H(l);
    }, J = ({ barOffsetPercent: l }, f = !1) => {
      const y = o.value.scrollWidth * (l / 100);
      v(y, f);
    }, K = (l) => {
      c.isScrolling = l;
    };
    let k = null;
    re(() => {
      k = new ResizeObserver(([l]) => {
        window.requestAnimationFrame(() => {
          a.value = l.contentRect.width, oe(() => {
            c.barWidthPercent = a.value / o.value.scrollWidth * 100;
          });
        });
      }), k.observe(o.value), s.value = !0, r.value !== 0 && g(r.value);
    }), ie(() => {
      k == null || k.disconnect();
    });
    const Q = T(() => Object.entries({
      "--gsc-item-gap-y": m.value.y,
      "--gsc-item-gap-x": m.value.x,
      "--gsc-item-ssr-min-width": e.ssrItemMinWidth ? `${parseInt(e.ssrItemMinWidth.toString())}px` : "",
      "--gsc-item-ssr-max-width": e.ssrItemMaxWidth ? `${parseInt(e.ssrItemMaxWidth.toString())}px` : ""
    }).reduce((l, [f, y]) => `${l}${f}: ${y};`, "")), Y = T(() => ({
      width: `calc((100% - ${e.previewSize}px) / ${e.itemsToShow})`
    }));
    return n({
      onMove: I,
      onMoveTo: g
    }), {
      trackRef: o,
      styles: Q,
      itemStyle: Y,
      initialized: s,
      disabledSide: i,
      indicatorOptions: c,
      scopedCurrentItem: r,
      currentItemByPercent: d,
      onMove: I,
      onMoveTo: g,
      onTrackScroll: Z,
      onIndicatorScroll: J,
      onSetIndicatorScrollStatus: K
    };
  }
});
const Ge = { class: "gsc-track__inner" };
function Ne(e, t, n, s, o, i) {
  const a = le("GSIndicator");
  return M(), O("div", {
    class: R(["gsc", {
      "gsc--scrolling": e.indicatorOptions.isScrolling,
      "gsc--initialized": e.initialized
    }]),
    style: C(e.styles)
  }, [
    (M(), se(ae(e.layout), ce({
      "on-move": e.onMove,
      "on-move-to": e.onMoveTo,
      "disabled-side": e.disabledSide,
      "current-item": e.scopedCurrentItem,
      "current-item-by-percent": e.currentItemByPercent,
      items: e.items,
      initialized: e.initialized
    }, e.layoutProps), {
      track: B(() => [
        $("div", {
          ref: "trackRef",
          class: "gsc-track",
          onScrollPassive: t[0] || (t[0] = (...r) => e.onTrackScroll && e.onTrackScroll(...r))
        }, [
          $("div", Ge, [
            (M(!0), O(ue, null, fe(e.items, (r, c) => (M(), O("div", {
              key: e.keyField ? r[e.keyField] : c,
              class: "gsc-track__item",
              style: C(e.itemStyle)
            }, [
              de(e.$slots, "item", {
                data: r,
                index: c
              })
            ], 4))), 128))
          ])
        ], 544)
      ]),
      indicator: B(() => [
        me(a, {
          "bar-offset-percent": e.indicatorOptions.barOffsetPercent,
          "bar-width-percent": e.indicatorOptions.barWidthPercent,
          onSmoothScroll: t[1] || (t[1] = (r) => e.onIndicatorScroll(r, !0)),
          onScroll: e.onIndicatorScroll,
          "onScroll:start": t[2] || (t[2] = (r) => e.onSetIndicatorScrollStatus(!0)),
          "onScroll:end": t[3] || (t[3] = (r) => e.onSetIndicatorScrollStatus(!1))
        }, null, 8, ["bar-offset-percent", "bar-width-percent", "onScroll"])
      ]),
      _: 3
    }, 16, ["on-move", "on-move-to", "disabled-side", "current-item", "current-item-by-percent", "items", "initialized"]))
  ], 6);
}
const Ae = /* @__PURE__ */ q(De, [["render", Ne]]);
export {
  Ae as GSCarousel,
  Xe as GSLayoutDefault,
  je as GSLayoutNumeric
};
//# sourceMappingURL=index.mjs.map
