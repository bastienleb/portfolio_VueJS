var z = 4, _ = 1e-3, h = 1e-7, V = 10, g = 11, o = 1 / (g - 1), D = typeof Float32Array == "function";
function w(n, r) {
  return 1 - 3 * r + 3 * n;
}
function b(n, r) {
  return 3 * r - 6 * n;
}
function y(n) {
  return 3 * n;
}
function N(n, r, e) {
  return ((w(r, e) * n + b(r, e)) * n + y(r)) * n;
}
function B(n, r, e) {
  return 3 * w(r, e) * n * n + 2 * b(r, e) * n + y(r);
}
function M(n, r, e, i, c) {
  var a, t, u = 0;
  do
    t = r + (e - r) / 2, a = N(t, i, c) - n, a > 0 ? e = t : r = t;
  while (Math.abs(a) > h && ++u < V);
  return t;
}
function P(n, r, e, i) {
  for (var c = 0; c < z; ++c) {
    var a = B(r, e, i);
    if (a === 0)
      return r;
    var t = N(r, e, i) - n;
    r -= t / a;
  }
  return r;
}
function q(n) {
  return n;
}
var R = function(r, e, i, c) {
  if (!(0 <= r && r <= 1 && 0 <= i && i <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (r === e && i === c)
    return q;
  for (var a = D ? new Float32Array(g) : new Array(g), t = 0; t < g; ++t)
    a[t] = N(t * o, r, i);
  function u(f) {
    for (var s = 0, v = 1, E = g - 1; v !== E && a[v] <= f; ++v)
      s += o;
    --v;
    var I = (f - a[v]) / (a[v + 1] - a[v]), l = s + I * o, S = B(l, r, i);
    return S >= _ ? P(f, l, r, i) : S === 0 ? l : M(f, s, s + o, r, i);
  }
  return function(s) {
    return s === 0 ? 0 : s === 1 ? 1 : N(u(s), e, c);
  };
};
const A = {
  ease: [0.25, 0.1, 0.25, 1],
  linear: [0, 0, 1, 1],
  easeIn: [0.42, 0, 1, 1],
  easeOut: [0, 0, 0.58, 1],
  easeInOut: [0.42, 0, 0.58, 1],
  default: [0.5, 0, 0.5, 1]
}, O = {
  FPS: 60,
  BEZIER: A.default
}, T = ({
  from: n,
  to: r,
  duration: e,
  fps: i = O.FPS,
  bezier: c = O.BEZIER,
  on: a,
  completed: t,
  stopped: u,
  done: f
}) => {
  const s = R(...c), v = r - n, E = Math.round(e / (1e3 / i));
  let I = 1, l = n;
  const S = setInterval(() => {
    let F = I / E;
    F > 1 && (F = 1), l = n + v * s(F), a(l), F === 1 && (clearInterval(S), t == null || t(l), f == null || f(l)), I++;
  }, e / E);
  return () => {
    clearInterval(S), u == null || u(l), f == null || f(l);
  };
}, U = ({
  from: n,
  to: r,
  duration: e,
  bezier: i = O.BEZIER,
  on: c,
  completed: a,
  stopped: t,
  done: u
}) => {
  const f = R(...i), s = r - n, v = Date.now();
  let E = 0, I = n;
  const l = () => {
    let S = (Date.now() - v) / e;
    if (S > 1 && (S = 1), I = n + s * f(S), c(I), S === 1) {
      a == null || a(I), u == null || u(I);
      return;
    }
    E = requestAnimationFrame(l);
  };
  return E = requestAnimationFrame(l), () => {
    cancelAnimationFrame(E), t == null || t(I), u == null || u(I);
  };
};
export {
  U as animate,
  T as animateUsingInterval,
  A as easingTypes
};
//# sourceMappingURL=index.mjs.map
